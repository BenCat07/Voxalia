#version 430 core

layout(binding = 0, r32f) uniform readonly image2D texture_ids;

layout(shared, binding = 1) buffer voxels
{
	uvec4[] posses;
};

layout(shared, binding = 2) buffer b_lightinfo
{
	uint[] f_lightinfos;
};

layout(local_size_x = MCM_VOX_COUNT, local_size_y = 1, local_size_z = MCM_VOX_COUNT) in;

#define MCM_LIGHTS 1
#include vox_helper.inc

void main()
{
	uvec3 pos = uvec3(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y % MCM_VOX_COUNT, gl_GlobalInvocationID.z);
	uint blkmult = gl_GlobalInvocationID.y / MCM_VOX_COUNT;
	uint id = blkSize() * blkmult + blockID(pos);
	uvec4 curBLK = posses[id];
	vec4 lit = getLightFor(curBLK.x);
	if (lit.w > 0.5)
	{
		uvec3 relAdd;
		float dst;
		if (blkmult < 4)
		{
			if (blkmult == 0)
			{
				relAdd = uvec3(MCM_VOX_COUNT);
				dst = 0;
			}
			else if (blkmult == 1)
			{
				relAdd = uvec3(0, MCM_VOX_COUNT, MCM_VOX_COUNT);
				dst = MCM_VOX_COUNT - pos.x;
			}
			else if (blkmult == 2)
			{
				relAdd = uvec3(MCM_VOX_COUNT * 2, MCM_VOX_COUNT, MCM_VOX_COUNT);
				dst = pos.x;
			}
			else // 3
			{
				relAdd = uvec3(MCM_VOX_COUNT, 0, MCM_VOX_COUNT);
				dst = MCM_VOX_COUNT - pos.y;
			}
		}
		else
		{
			if (blkmult == 4)
			{
				relAdd = uvec3(MCM_VOX_COUNT, MCM_VOX_COUNT * 2, MCM_VOX_COUNT);
				dst = pos.y;
			}
			else if (blkmult == 5)
			{
				relAdd = uvec3(MCM_VOX_COUNT, 0, MCM_VOX_COUNT);
				dst = MCM_VOX_COUNT - pos.z;
			}
			else // 6
			{
				relAdd = uvec3(MCM_VOX_COUNT, MCM_VOX_COUNT * 2, MCM_VOX_COUNT);
				dst = pos.z;
			}
		}
		if (lit.w >= dst)
		{
			uint idT = atomicAdd(f_lightinfos[0], 1);
			if (idT < 256)
			{
				idT *= 7;
				idT += 1;
				f_lightinfos[idT + 0] = relAdd.x + pos.x;
				f_lightinfos[idT + 1] = relAdd.y + pos.y;
				f_lightinfos[idT + 2] = relAdd.z + pos.z;
				f_lightinfos[idT + 3] = floatBitsToUint(lit.x);
				f_lightinfos[idT + 4] = floatBitsToUint(lit.y);
				f_lightinfos[idT + 5] = floatBitsToUint(lit.z);
				f_lightinfos[idT + 6] = floatBitsToUint(lit.w);
			}
		}
	}
}
